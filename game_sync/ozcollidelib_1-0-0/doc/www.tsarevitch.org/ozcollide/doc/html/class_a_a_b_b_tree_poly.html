<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ozcollide: AABBTreePoly Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>


<!-- Copyright © 2008. Spidersoft Ltd -->
<style>
A.applink:hover {border: 2px dotted #DCE6F4;padding:2px;background-color:#ffff00;color:green;text-decoration:none}
A.applink       {border: 2px dotted #DCE6F4;padding:2px;color:#2F5BFF;background:transparent;text-decoration:none}
A.info          {color:#2F5BFF;background:transparent;text-decoration:none}
A.info:hover    {color:green;background:transparent;text-decoration:underline}
</style>
<div style='BORDER: 1px solid #DCE6F4; MARGIN-TOP: 20px; MARGIN-BOTTOM: 20px; MARGIN-LEFT: 5px; MARGIN-RIGHT: 5px; PADDING: 5px; BACKGROUND-COLOR: #eef8ff;line-height:180%; COLOR: #000000; font-family: Arial; font-size: 8pt; width=100%; FILTER: progid:DXImageTransform.Microsoft.Gradient(GradientType=0, StartColorStr="#FFFFFFFF", EndColorStr="#F2F5FAFF");'>
This page was saved using <a class="applink" href="http://www.spidersoft.com"><b>WebZIP 7.1.2.1052</b></a> <a class="applink" href="http://www.spidersoft.com"><b>offline browser</b></a>  (Unregistered) on  02/01/09 15:21:55.<br>
<b>Address:</b> <a class="info" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html">http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html</a><br>
<b>Title:</b> ozcollide: AABBTreePoly Class Reference &nbsp;&bull;&nbsp; <b>Size:</b> 66383 &nbsp;&bull;&nbsp; <b>Last Modified:</b> Tue, 04 Nov 2008 13:31:13 GMT<br></div>
<!-- /Copyright © 2008. Spidersoft Ltd -->


<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>AABBTreePoly Class Reference</h1><!-- doxytag: class="AABBTreePoly" --><!-- doxytag: inherits="AABBTree" --><code>#include &lt;<a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h-source.html">aabbtree_poly.h</a>&gt;</code>
<p>
<p>Inheritance diagram for AABBTreePoly:
<p><center><img src="class_a_a_b_b_tree_poly.png" usemap="#AABBTreePoly_map" border="0" alt=""></center>
<map name="AABBTreePoly_map">
<area href="class_a_a_b_b_tree.html" alt="AABBTree" shape="rect" coords="0,0,97,24">
</map>
<a href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Implementation of an AABB tree that contains one or more polygon(s) on leaves (depending of the depth used at tree construction). 
<p>

<p>
Definition at line <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h-source.html#l00066">66</a> of file <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h-source.html">aabbtree_poly.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/ozcollide_8h.html#50d8f4457c9217d584d36a3352a55103">ERR</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#b42af7052e874191df592d0942c88a41">saveBinary</a> (const char *_filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves the tree in binary (optimised) format.  <a href="#b42af7052e874191df592d0942c88a41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/ozcollide_8h.html#50d8f4457c9217d584d36a3352a55103">ERR</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#c5c9f6933cf33668e2e64d819cee008c">saveBinary</a> (<a class="el" href="class_data_out.html">DataOut</a> &amp;_out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves the tree in binary (optimised) format.  <a href="#c5c9f6933cf33668e2e64d819cee008c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#8b8181b8a1ba2785669c637122e75568">getMemoryConsumption</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the memory consumption of the entire content of the tree in bytes.  <a href="#8b8181b8a1ba2785669c637122e75568"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#51e26898dda930b6ca3b330abbc69e0d">getNbPoints</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of 3d points used in the tree.  <a href="#51e26898dda930b6ca3b330abbc69e0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API const <a class="el" href="class_vec3f.html">Vec3f</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#f8abe0d6b49b5131ff17d28da76f294e">getPointsList</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list of 3d points used in the tree.  <a href="#f8abe0d6b49b5131ff17d28da76f294e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#02d1eda17064ce42548058d95aa4f763">isCollideWithBox</a> (const <a class="el" href="class_box.html">Box</a> &amp;_box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests a collision with a box.  <a href="#02d1eda17064ce42548058d95aa4f763"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#f5b66f455544ae4df518fd4a9aa40819">isCollideWithBox</a> (const <a class="el" href="class_box.html">Box</a> &amp;_box, <a class="el" href="class_a_a_b_b_tree_poly_1_1_box_col_result.html">BoxColResult</a> &amp;_result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests a collision with a box.  <a href="#f5b66f455544ae4df518fd4a9aa40819"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#1d24a908f211344a11191eb7379f6430">collideWithBox</a> (const <a class="el" href="class_box.html">Box</a> &amp;_box, <a class="el" href="class_a_a_b_b_tree_poly_1_1_box_col_result.html">BoxColResult</a> &amp;_result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines all polygons that collide with a box.  <a href="#1d24a908f211344a11191eb7379f6430"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#fa010494d6fc9220746cc8b8ebb931fa">collideWithBox</a> (const <a class="el" href="class_box.html">Box</a> &amp;_box, <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h.html#96bbb372c9897aa4a84c47f46bb9d1aa">AABBCDPoly_callback</a> *_callback, void *_userCallback=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines all polygons that collide with a box.  <a href="#fa010494d6fc9220746cc8b8ebb931fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#5876586416dae283dd1b46c500106ba3">isCollideWithSphere</a> (const <a class="el" href="class_sphere.html">Sphere</a> &amp;_sphere)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests a collision with a sphere.  <a href="#5876586416dae283dd1b46c500106ba3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#31f75a7d85519059093b9260ed8a14b7">collideWithSphere</a> (const <a class="el" href="class_sphere.html">Sphere</a> &amp;_sphere, <a class="el" href="class_a_a_b_b_tree_poly_1_1_sphere_col_result.html">SphereColResult</a> &amp;_result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines all polygons that collide with a sphere.  <a href="#31f75a7d85519059093b9260ed8a14b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#551c70c71ba7ea73abddc4f0451652b9">collideWithSphere</a> (const <a class="el" href="class_sphere.html">Sphere</a> &amp;_sphere, <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h.html#96bbb372c9897aa4a84c47f46bb9d1aa">AABBCDPoly_callback</a> *_callback, void *_userCallback=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines all polygons that collide with a sphere.  <a href="#551c70c71ba7ea73abddc4f0451652b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#dbd4be7655f7233fd42c86acabfaf437">isCollideWithEllipsoid</a> (const <a class="el" href="class_ellipsoid.html">Ellipsoid</a> &amp;_ellipsoid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests a collision with an ellipsoid.  <a href="#dbd4be7655f7233fd42c86acabfaf437"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#1fb75220498e7e574a12ce5d2ee5777d">collideWithEllipsoid</a> (const <a class="el" href="class_ellipsoid.html">Ellipsoid</a> &amp;_ellipsoid, <a class="el" href="class_a_a_b_b_tree_poly_1_1_ellipsoid_col_result.html">EllipsoidColResult</a> &amp;_result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines all polygons that collide with an ellipsoid.  <a href="#1fb75220498e7e574a12ce5d2ee5777d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#ab509ee3e59603e1ea5b9e2abb484b49">collideWithEllipsoid</a> (const <a class="el" href="class_ellipsoid.html">Ellipsoid</a> &amp;_ellipsoid, <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h.html#96bbb372c9897aa4a84c47f46bb9d1aa">AABBCDPoly_callback</a> *_callback, void *_userCallback=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines all polygons that collide with an ellipsoid.  <a href="#ab509ee3e59603e1ea5b9e2abb484b49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#83b6a3625b205c007fefb843e6c6812b">isCollideWithSegment</a> (const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;_seg_pt0, const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;_seg_pt1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests a collision with a segment.  <a href="#83b6a3625b205c007fefb843e6c6812b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#237e692e70896f928dfea4cd7e756b08">isCollideWithSegment</a> (const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;_seg_pt0, const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;_seg_pt1, <a class="el" href="class_a_a_b_b_tree_poly_1_1_segment_col_result.html">SegmentColResult</a> &amp;_result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests a collision with an ellipsoid.  <a href="#237e692e70896f928dfea4cd7e756b08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#e88f44c0390cd63e0dc7a3bbcacffa0f">collideWithSegment</a> (const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;_seg_pt0, const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;_seg_pt1, <a class="el" href="class_a_a_b_b_tree_poly_1_1_segment_col_result.html">SegmentColResult</a> &amp;_result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines all polygons that collide with a segment.  <a href="#e88f44c0390cd63e0dc7a3bbcacffa0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#0df92aa7a85370da23780bac18d217e1">collideWithSegment</a> (const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;_seg_pt0, const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;_seg_pt1, <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h.html#96bbb372c9897aa4a84c47f46bb9d1aa">AABBCDPoly_callback</a> *_callback, void *_userCallback=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines all polygons that collide with a segment.  <a href="#0df92aa7a85370da23780bac18d217e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#b3f2d00daae715929de3746f726ba97a">isCollideWithOBB</a> (const <a class="el" href="class_o_b_b.html">OBB</a> &amp;_obb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests a collision with an <a class="el" href="class_o_b_b.html">OBB</a>.  <a href="#b3f2d00daae715929de3746f726ba97a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#ba40c48a9db2cf1bad32fefea951e9bc">isCollideWithOBB</a> (const <a class="el" href="class_o_b_b.html">OBB</a> &amp;_obb, <a class="el" href="class_a_a_b_b_tree_poly_1_1_o_b_b_col_result.html">OBBColResult</a> &amp;_result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests a collision with an <a class="el" href="class_o_b_b.html">OBB</a>.  <a href="#ba40c48a9db2cf1bad32fefea951e9bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#665b53b97124477e958d861c773f3cbd">collideWithOBB</a> (const <a class="el" href="class_o_b_b.html">OBB</a> &amp;_obb, <a class="el" href="class_a_a_b_b_tree_poly_1_1_o_b_b_col_result.html">OBBColResult</a> &amp;_result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines all polygons that collide with an <a class="el" href="class_o_b_b.html">OBB</a>.  <a href="#665b53b97124477e958d861c773f3cbd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#f7ffbd3da7f99b262681311d24a8e9a8">collideWithOBB</a> (const <a class="el" href="class_o_b_b.html">OBB</a> &amp;_obb, <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h.html#96bbb372c9897aa4a84c47f46bb9d1aa">AABBCDPoly_callback</a> *_callback, void *_userCallback=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines all polygons that collide with an <a class="el" href="class_o_b_b.html">OBB</a>.  <a href="#f7ffbd3da7f99b262681311d24a8e9a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#21fa3eb42c5fe17f2c059b6fa08a4b8a">getNbCollidedPrimitives</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of collided primitives since the last collision query.  <a href="#21fa3eb42c5fe17f2c059b6fa08a4b8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">OZCOLLIDE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#0e2fc0fb81bdcb3ba4da05c5f7189784">scale</a> (float _factor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales the entire tree (nodes + leafs).  <a href="#0e2fc0fb81bdcb3ba4da05c5f7189784"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static OZCOLLIDE_API <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/ozcollide_8h.html#50d8f4457c9217d584d36a3352a55103">ERR</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#028d38bfb5a68ab7db59263863b9c49c">loadBinary</a> (const char *_filename, <a class="el" href="class_a_a_b_b_tree_poly.html">AABBTreePoly</a> **_tree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a tree from disk.  <a href="#028d38bfb5a68ab7db59263863b9c49c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static OZCOLLIDE_API <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/ozcollide_8h.html#50d8f4457c9217d584d36a3352a55103">ERR</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#0f0ea4fa035d3a78f8d93a15872a6daa">loadBinary</a> (<a class="el" href="class_data_in.html">DataIn</a> &amp;_in, <a class="el" href="class_a_a_b_b_tree_poly.html">AABBTreePoly</a> **_tree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a tree from a given <a class="el" href="class_data_in.html">DataIn</a> instance.  <a href="#0f0ea4fa035d3a78f8d93a15872a6daa"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#2339421afaea5950f02315d9c34245cb">AABBTree</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly.html#ec3c733420feef4fbb9f1cbabd3fbb3b">AABBTreePolyBuilder</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_a_b_b_tree_poly_1_1_box_col_result.html">BoxColResult</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nested class to hold result of a box collision detection.  <a href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly_1_1_box_col_result.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_a_b_b_tree_poly_1_1_ellipsoid_col_result.html">EllipsoidColResult</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nested class to hold result of an ellipsoid collision detection.  <a href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly_1_1_ellipsoid_col_result.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_a_b_b_tree_poly_1_1_o_b_b_col_result.html">OBBColResult</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nested class to hold result of an <a class="el" href="class_o_b_b.html">OBB</a> collision detection.  <a href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly_1_1_o_b_b_col_result.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_a_b_b_tree_poly_1_1_segment_col_result.html">SegmentColResult</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nested class to hold result of a segment collision detection.  <a href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly_1_1_segment_col_result.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_a_b_b_tree_poly_1_1_sphere_col_result.html">SphereColResult</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nested class to hold result of a sphere collision detection.  <a href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree_poly_1_1_sphere_col_result.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="028d38bfb5a68ab7db59263863b9c49c"></a><!-- doxytag: member="AABBTreePoly::loadBinary" ref="028d38bfb5a68ab7db59263863b9c49c" args="(const char *_filename, AABBTreePoly **_tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OZCOLLIDE_API <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/ozcollide_8h.html#50d8f4457c9217d584d36a3352a55103">ERR</a> loadBinary           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_a_b_b_tree_poly.html">AABBTreePoly</a> **&nbsp;</td>
          <td class="paramname"> <em>_tree</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads a tree from disk. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_filename</em>&nbsp;</td><td>[in] The filename on disk </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_tree</em>&nbsp;</td><td>[in, out] The tree pointer if succesful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (NOERR) on success, any other values otherwhise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0f0ea4fa035d3a78f8d93a15872a6daa"></a><!-- doxytag: member="AABBTreePoly::loadBinary" ref="0f0ea4fa035d3a78f8d93a15872a6daa" args="(DataIn &amp;_in, AABBTreePoly **_tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OZCOLLIDE_API <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/ozcollide_8h.html#50d8f4457c9217d584d36a3352a55103">ERR</a> loadBinary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_data_in.html">DataIn</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_a_b_b_tree_poly.html">AABBTreePoly</a> **&nbsp;</td>
          <td class="paramname"> <em>_tree</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads a tree from a given <a class="el" href="class_data_in.html">DataIn</a> instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_in</em>&nbsp;</td><td>[in] The <a class="el" href="class_data_in.html">DataIn</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_tree</em>&nbsp;</td><td>[in, out] The tree pointer if succesful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (NOERR) on success, any other values otherwhise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b42af7052e874191df592d0942c88a41"></a><!-- doxytag: member="AABBTreePoly::saveBinary" ref="b42af7052e874191df592d0942c88a41" args="(const char *_filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/ozcollide_8h.html#50d8f4457c9217d584d36a3352a55103">ERR</a> saveBinary           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>_filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the tree in binary (optimised) format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_filename</em>&nbsp;</td><td>[in] The filename on disk. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (NOERR) on success, any other values otherwhise. </dd></dl>

<p>
Implements <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree.html#6bdc21215a8a3fdcb2d2a7fc5b9ba691">AABBTree</a>.
</div>
</div><p>
<a class="anchor" name="c5c9f6933cf33668e2e64d819cee008c"></a><!-- doxytag: member="AABBTreePoly::saveBinary" ref="c5c9f6933cf33668e2e64d819cee008c" args="(DataOut &amp;_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/ozcollide_8h.html#50d8f4457c9217d584d36a3352a55103">ERR</a> saveBinary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_data_out.html">DataOut</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_out</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the tree in binary (optimised) format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_out</em>&nbsp;</td><td>[in] The <a class="el" href="class_data_out.html">DataOut</a> instance to use for saving. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (NOERR) on success, any other values otherwhise. </dd></dl>

<p>
Implements <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree.html#aaa7ec75bc26e384675360d96e801b0d">AABBTree</a>.
</div>
</div><p>
<a class="anchor" name="8b8181b8a1ba2785669c637122e75568"></a><!-- doxytag: member="AABBTreePoly::getMemoryConsumption" ref="8b8181b8a1ba2785669c637122e75568" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API int getMemoryConsumption           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the memory consumption of the entire content of the tree in bytes. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The amount of memory of the tree in bytes. </dd></dl>

<p>
Implements <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree.html#e66a348f8d72f58e3ad9ea9486a6db7d">AABBTree</a>.
</div>
</div><p>
<a class="anchor" name="51e26898dda930b6ca3b330abbc69e0d"></a><!-- doxytag: member="AABBTreePoly::getNbPoints" ref="51e26898dda930b6ca3b330abbc69e0d" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API int getNbPoints           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of 3d points used in the tree. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of points of the tree. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f8abe0d6b49b5131ff17d28da76f294e"></a><!-- doxytag: member="AABBTreePoly::getPointsList" ref="f8abe0d6b49b5131ff17d28da76f294e" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API const <a class="el" href="class_vec3f.html">Vec3f</a>* getPointsList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a list of 3d points used in the tree. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The list of 3d points of the tree. </dd></dl>

</div>
</div><p>
<a class="anchor" name="02d1eda17064ce42548058d95aa4f763"></a><!-- doxytag: member="AABBTreePoly::isCollideWithBox" ref="02d1eda17064ce42548058d95aa4f763" args="(const Box &amp;_box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API bool isCollideWithBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests a collision with a box. 
<p>
This is a brute force method that simply returns a boolean. No caching and/or temporal coherence can be used. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_box</em>&nbsp;</td><td>[in] The box to test collision with. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if collision occurs, false otherwhise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5b66f455544ae4df518fd4a9aa40819"></a><!-- doxytag: member="AABBTreePoly::isCollideWithBox" ref="f5b66f455544ae4df518fd4a9aa40819" args="(const Box &amp;_box, BoxColResult &amp;_result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API bool isCollideWithBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_a_b_b_tree_poly_1_1_box_col_result.html">BoxColResult</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests a collision with a box. 
<p>
Simply returns a boolean, uses collision cache if temporal coherence is turned on. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_box</em>&nbsp;</td><td>[in] The box to test collision with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_result</em>&nbsp;</td><td>[in, out] Result of the query. Contains only the first polygon that collides. Collision cache (if used) needs to have the same <a class="el" href="class_a_a_b_b_tree_poly_1_1_box_col_result.html">BoxColResult</a> instance passed again and again. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if collision occurs, false otherwhise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1d24a908f211344a11191eb7379f6430"></a><!-- doxytag: member="AABBTreePoly::collideWithBox" ref="1d24a908f211344a11191eb7379f6430" args="(const Box &amp;_box, BoxColResult &amp;_result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API void collideWithBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_a_b_b_tree_poly_1_1_box_col_result.html">BoxColResult</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines all polygons that collide with a box. 
<p>
Fill <a class="el" href="class_a_a_b_b_tree_poly_1_1_box_col_result.html">BoxColResult</a> with the result of the collision. If temporal coherence is turned on, the current content of <a class="el" href="class_a_a_b_b_tree_poly_1_1_box_col_result.html">BoxColResult</a> is taken as a collision cache. The method then returns immediatly if the box is inside 'boxQuery' (which has been usually inflated to favorise collision cache). 'boxQuery' is updated by the method itself when required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_box</em>&nbsp;</td><td>[in] The box to test collision with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_result</em>&nbsp;</td><td>[in, out] Result of the query. Contains all polygons that collide. Collision cache (if used) needs to have the same <a class="el" href="class_a_a_b_b_tree_poly_1_1_box_col_result.html">BoxColResult</a> instance passed again and again. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fa010494d6fc9220746cc8b8ebb931fa"></a><!-- doxytag: member="AABBTreePoly::collideWithBox" ref="fa010494d6fc9220746cc8b8ebb931fa" args="(const Box &amp;_box, AABBCDPoly_callback *_callback, void *_userCallback=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API void collideWithBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h.html#96bbb372c9897aa4a84c47f46bb9d1aa">AABBCDPoly_callback</a> *&nbsp;</td>
          <td class="paramname"> <em>_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>_userCallback</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines all polygons that collide with a box. 
<p>
Perform a brute query and return result through a callback. No caching and/or temporal coherence are used. This method should be used only when memory usage is a concern. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_box</em>&nbsp;</td><td>[in] The box to test collision with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_callback</em>&nbsp;</td><td>[in] Callback invoked each time a collision occurs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_userCallback</em>&nbsp;</td><td>[in] User value passed to the callback. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5876586416dae283dd1b46c500106ba3"></a><!-- doxytag: member="AABBTreePoly::isCollideWithSphere" ref="5876586416dae283dd1b46c500106ba3" args="(const Sphere &amp;_sphere)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API bool isCollideWithSphere           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sphere.html">Sphere</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_sphere</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests a collision with a sphere. 
<p>
This is a brute force method that simply returns a boolean. No caching and/or temporal coherence can be used. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_sphere</em>&nbsp;</td><td>[in] The sphere to test collision with. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if collision occurs, false otherwhise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="31f75a7d85519059093b9260ed8a14b7"></a><!-- doxytag: member="AABBTreePoly::collideWithSphere" ref="31f75a7d85519059093b9260ed8a14b7" args="(const Sphere &amp;_sphere, SphereColResult &amp;_result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API void collideWithSphere           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sphere.html">Sphere</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_a_b_b_tree_poly_1_1_sphere_col_result.html">SphereColResult</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines all polygons that collide with a sphere. 
<p>
Fill <a class="el" href="class_a_a_b_b_tree_poly_1_1_sphere_col_result.html">SphereColResult</a> with the result of the collision. If temporal coherence is turned on, the current content of <a class="el" href="class_a_a_b_b_tree_poly_1_1_sphere_col_result.html">SphereColResult</a> is taken as a collision cache. The method then returns immediatly if the sphere is inside 'sphereQuery' (which has been usually inflated to favorise collision cache). 'sphereQuery' is updated by the method itself when required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_sphere</em>&nbsp;</td><td>[in] The sphere to test collision with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_result</em>&nbsp;</td><td>[in, out] Result of the query. Contains all polygons that collide. Collision cache (if used) needs to have the same <a class="el" href="class_a_a_b_b_tree_poly_1_1_sphere_col_result.html">SphereColResult</a> instance passed again and again. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="551c70c71ba7ea73abddc4f0451652b9"></a><!-- doxytag: member="AABBTreePoly::collideWithSphere" ref="551c70c71ba7ea73abddc4f0451652b9" args="(const Sphere &amp;_sphere, AABBCDPoly_callback *_callback, void *_userCallback=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API void collideWithSphere           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sphere.html">Sphere</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h.html#96bbb372c9897aa4a84c47f46bb9d1aa">AABBCDPoly_callback</a> *&nbsp;</td>
          <td class="paramname"> <em>_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>_userCallback</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines all polygons that collide with a sphere. 
<p>
Perform a brute query and return result through a callback. No caching and/or temporal coherence are used. This method should be used only when memory usage is a concern. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_sphere</em>&nbsp;</td><td>[in] The sphere to test collision with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_callback</em>&nbsp;</td><td>[in] Callback invoked each time a collision occurs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_userCallback</em>&nbsp;</td><td>[in] User value passed to the callback. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dbd4be7655f7233fd42c86acabfaf437"></a><!-- doxytag: member="AABBTreePoly::isCollideWithEllipsoid" ref="dbd4be7655f7233fd42c86acabfaf437" args="(const Ellipsoid &amp;_ellipsoid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API bool isCollideWithEllipsoid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ellipsoid.html">Ellipsoid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_ellipsoid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests a collision with an ellipsoid. 
<p>
This is a brute force method that simply returns a boolean. No caching and/or temporal coherence can be used. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_ellipsoid</em>&nbsp;</td><td>[in] The ellipsoid to test collision with. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if collision occurs, false otherwhise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1fb75220498e7e574a12ce5d2ee5777d"></a><!-- doxytag: member="AABBTreePoly::collideWithEllipsoid" ref="1fb75220498e7e574a12ce5d2ee5777d" args="(const Ellipsoid &amp;_ellipsoid, EllipsoidColResult &amp;_result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API void collideWithEllipsoid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ellipsoid.html">Ellipsoid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_ellipsoid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_a_b_b_tree_poly_1_1_ellipsoid_col_result.html">EllipsoidColResult</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines all polygons that collide with an ellipsoid. 
<p>
Fill <a class="el" href="class_a_a_b_b_tree_poly_1_1_ellipsoid_col_result.html">EllipsoidColResult</a> with the result of the collision. If temporal coherence is turned on, the current content of <a class="el" href="class_a_a_b_b_tree_poly_1_1_ellipsoid_col_result.html">EllipsoidColResult</a> is taken as a collision cache. The method then returns immediatly if the ellipsoid is inside 'ellipsoidQuery' (which has been usually inflated to favorise collision cache). 'ellipsoidQuery' is updated by the method itself when required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_ellipsoid</em>&nbsp;</td><td>[in] The ellipsoid to test collision with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_result</em>&nbsp;</td><td>[in, out] Result of the query. Contains all polygons that collide. Collision cache (if used) needs to have the same <a class="el" href="class_a_a_b_b_tree_poly_1_1_ellipsoid_col_result.html">EllipsoidColResult</a> instance passed again and again. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ab509ee3e59603e1ea5b9e2abb484b49"></a><!-- doxytag: member="AABBTreePoly::collideWithEllipsoid" ref="ab509ee3e59603e1ea5b9e2abb484b49" args="(const Ellipsoid &amp;_ellipsoid, AABBCDPoly_callback *_callback, void *_userCallback=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API void collideWithEllipsoid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ellipsoid.html">Ellipsoid</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_ellipsoid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h.html#96bbb372c9897aa4a84c47f46bb9d1aa">AABBCDPoly_callback</a> *&nbsp;</td>
          <td class="paramname"> <em>_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>_userCallback</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines all polygons that collide with an ellipsoid. 
<p>
Perform a brute query and return result through a callback. No caching and/or temporal coherence are used. This method should be used only when memory usage is a concern. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_ellipsoid</em>&nbsp;</td><td>[in] The ellipsoid to test collision with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_callback</em>&nbsp;</td><td>[in] Callback invoked each time a collision occurs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_userCallback</em>&nbsp;</td><td>[in] User value passed to the callback. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="83b6a3625b205c007fefb843e6c6812b"></a><!-- doxytag: member="AABBTreePoly::isCollideWithSegment" ref="83b6a3625b205c007fefb843e6c6812b" args="(const Vec3f &amp;_seg_pt0, const Vec3f &amp;_seg_pt1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API bool isCollideWithSegment           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_seg_pt0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_seg_pt1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests a collision with a segment. 
<p>
This is a brute force method that simply returns a boolean. No caching and/or temporal coherence can be used. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_seg_pt0</em>&nbsp;</td><td>[in] The first point of the segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_seg_pt1</em>&nbsp;</td><td>[in] The second point of the segment. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if collision occurs, false otherwhise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="237e692e70896f928dfea4cd7e756b08"></a><!-- doxytag: member="AABBTreePoly::isCollideWithSegment" ref="237e692e70896f928dfea4cd7e756b08" args="(const Vec3f &amp;_seg_pt0, const Vec3f &amp;_seg_pt1, SegmentColResult &amp;_result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API bool isCollideWithSegment           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_seg_pt0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_seg_pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_a_b_b_tree_poly_1_1_segment_col_result.html">SegmentColResult</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests a collision with an ellipsoid. 
<p>
Simply returns a boolean, uses collision cache if temporal coherence is turned on. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_seg_pt0</em>&nbsp;</td><td>[in] The first point of the segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_seg_pt1</em>&nbsp;</td><td>[in] The second point of the segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_result</em>&nbsp;</td><td>[in, out] Result of the query. Contains only the first polygon that collides. Collision cache (if used) needs to have the same <a class="el" href="class_a_a_b_b_tree_poly_1_1_segment_col_result.html">SegmentColResult</a> instance passed again and again. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if collision occurs, false otherwhise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e88f44c0390cd63e0dc7a3bbcacffa0f"></a><!-- doxytag: member="AABBTreePoly::collideWithSegment" ref="e88f44c0390cd63e0dc7a3bbcacffa0f" args="(const Vec3f &amp;_seg_pt0, const Vec3f &amp;_seg_pt1, SegmentColResult &amp;_result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API void collideWithSegment           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_seg_pt0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_seg_pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_a_b_b_tree_poly_1_1_segment_col_result.html">SegmentColResult</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines all polygons that collide with a segment. 
<p>
Fill <a class="el" href="class_a_a_b_b_tree_poly_1_1_segment_col_result.html">SegmentColResult</a> with the result of the collision. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_seg_pt0</em>&nbsp;</td><td>[in] The first point of the segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_seg_pt1</em>&nbsp;</td><td>[in] The second point of the segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_result</em>&nbsp;</td><td>[in, out] Result of the query. Contains all polygons that collide with the segment. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0df92aa7a85370da23780bac18d217e1"></a><!-- doxytag: member="AABBTreePoly::collideWithSegment" ref="0df92aa7a85370da23780bac18d217e1" args="(const Vec3f &amp;_seg_pt0, const Vec3f &amp;_seg_pt1, AABBCDPoly_callback *_callback, void *_userCallback=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API void collideWithSegment           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_seg_pt0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_vec3f.html">Vec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_seg_pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h.html#96bbb372c9897aa4a84c47f46bb9d1aa">AABBCDPoly_callback</a> *&nbsp;</td>
          <td class="paramname"> <em>_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>_userCallback</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines all polygons that collide with a segment. 
<p>
This method should be used only when memory usage is a concern. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_seg_pt0</em>&nbsp;</td><td>[in] The first point of the segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_seg_pt1</em>&nbsp;</td><td>[in] The second point of the segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_callback</em>&nbsp;</td><td>[in] Callback invoked each time a collision occurs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_userCallback</em>&nbsp;</td><td>[in] User value passed to the callback. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b3f2d00daae715929de3746f726ba97a"></a><!-- doxytag: member="AABBTreePoly::isCollideWithOBB" ref="b3f2d00daae715929de3746f726ba97a" args="(const OBB &amp;_obb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API bool isCollideWithOBB           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_b_b.html">OBB</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_obb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests a collision with an <a class="el" href="class_o_b_b.html">OBB</a>. 
<p>
This is a brute force method that simply returns a boolean. No caching and/or temporal coherence can be used. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_obb</em>&nbsp;</td><td>[in] The obb to test collision with. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if collision occurs, false otherwhise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba40c48a9db2cf1bad32fefea951e9bc"></a><!-- doxytag: member="AABBTreePoly::isCollideWithOBB" ref="ba40c48a9db2cf1bad32fefea951e9bc" args="(const OBB &amp;_obb, OBBColResult &amp;_result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API bool isCollideWithOBB           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_b_b.html">OBB</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_obb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_a_b_b_tree_poly_1_1_o_b_b_col_result.html">OBBColResult</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests a collision with an <a class="el" href="class_o_b_b.html">OBB</a>. 
<p>
Simply returns a boolean, uses collision cache if temporal coherence is turned on. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_obb</em>&nbsp;</td><td>[in] The <a class="el" href="class_o_b_b.html">OBB</a> to test collision with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_result</em>&nbsp;</td><td>[in, out] Result of the query. Contains only the first polygon that collides. Collision cache (if used) needs to have the same <a class="el" href="class_a_a_b_b_tree_poly_1_1_o_b_b_col_result.html">OBBColResult</a> instance passed again and again. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if collision occurs, false otherwhise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="665b53b97124477e958d861c773f3cbd"></a><!-- doxytag: member="AABBTreePoly::collideWithOBB" ref="665b53b97124477e958d861c773f3cbd" args="(const OBB &amp;_obb, OBBColResult &amp;_result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API void collideWithOBB           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_b_b.html">OBB</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_obb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_a_b_b_tree_poly_1_1_o_b_b_col_result.html">OBBColResult</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines all polygons that collide with an <a class="el" href="class_o_b_b.html">OBB</a>. 
<p>
Fill <a class="el" href="class_a_a_b_b_tree_poly_1_1_o_b_b_col_result.html">OBBColResult</a> with the result of the collision. If temporal coherence is turned on, the current content of <a class="el" href="class_a_a_b_b_tree_poly_1_1_o_b_b_col_result.html">OBBColResult</a> is taken as a collision cache. The method then returns immediatly if the <a class="el" href="class_o_b_b.html">OBB</a> is inside 'obbQuery' (which has been usually inflated to favorise collision cache). 'obbQuery' is updated by the method itself when required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_obb</em>&nbsp;</td><td>[in] The <a class="el" href="class_o_b_b.html">OBB</a> to test collision with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_result</em>&nbsp;</td><td>[in, out] Result of the query. Contains all polygons that collide. Collision cache (if used) needs to have the same <a class="el" href="class_a_a_b_b_tree_poly_1_1_o_b_b_col_result.html">OBBColResult</a> instance passed again and again. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f7ffbd3da7f99b262681311d24a8e9a8"></a><!-- doxytag: member="AABBTreePoly::collideWithOBB" ref="f7ffbd3da7f99b262681311d24a8e9a8" args="(const OBB &amp;_obb, AABBCDPoly_callback *_callback, void *_userCallback=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API void collideWithOBB           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_b_b.html">OBB</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_obb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h.html#96bbb372c9897aa4a84c47f46bb9d1aa">AABBCDPoly_callback</a> *&nbsp;</td>
          <td class="paramname"> <em>_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>_userCallback</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines all polygons that collide with an <a class="el" href="class_o_b_b.html">OBB</a>. 
<p>
Perform a brute query and return result through a callback. No caching and/or temporal coherence are used. This method should be used only when memory usage is a concern. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_obb</em>&nbsp;</td><td>[in] The <a class="el" href="class_o_b_b.html">OBB</a> to test collision with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_callback</em>&nbsp;</td><td>[in] Callback invoked each time a collision occurs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_userCallback</em>&nbsp;</td><td>[in] User value passed to the callback. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="21fa3eb42c5fe17f2c059b6fa08a4b8a"></a><!-- doxytag: member="AABBTreePoly::getNbCollidedPrimitives" ref="21fa3eb42c5fe17f2c059b6fa08a4b8a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API int getNbCollidedPrimitives           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of collided primitives since the last collision query. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of collided primitives. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e2fc0fb81bdcb3ba4da05c5f7189784"></a><!-- doxytag: member="AABBTreePoly::scale" ref="0e2fc0fb81bdcb3ba4da05c5f7189784" args="(float _factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OZCOLLIDE_API void scale           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>_factor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scales the entire tree (nodes + leafs). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_factor</em>&nbsp;</td><td>[in] The scale factor. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/class_a_a_b_b_tree.html#56f566db49322c0e87035eef676dbc5e">AABBTree</a>.
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="2339421afaea5950f02315d9c34245cb"></a><!-- doxytag: member="AABBTreePoly::AABBTree" ref="2339421afaea5950f02315d9c34245cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_a_a_b_b_tree.html">AABBTree</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h-source.html#l00382">382</a> of file <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h-source.html">aabbtree_poly.h</a>.
</div>
</div><p>
<a class="anchor" name="ec3c733420feef4fbb9f1cbabd3fbb3b"></a><!-- doxytag: member="AABBTreePoly::AABBTreePolyBuilder" ref="ec3c733420feef4fbb9f1cbabd3fbb3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_a_a_b_b_tree_poly_builder.html">AABBTreePolyBuilder</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h-source.html#l00383">383</a> of file <a class="el" href="http://www.tsarevitch.org/ozcollide/doc/html/aabbtree__poly_8h-source.html">aabbtree_poly.h</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 5 17:37:21 2008 for ozcollide by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
